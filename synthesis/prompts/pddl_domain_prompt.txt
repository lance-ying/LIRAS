You will read instructions about a game setup and then synthesize a PDDL domain for the text description you are given.

Note that in our PDDL definition, we use a bit-matrix and array to represent different types of cells. These cell types generally refer to generic barriers or terrains where the agent can or cannot occupy and should span multiple cells. 

If the same actions have different costs depending on the cells it is located, then each type of cell should have a separate action definition. Note that the costs of actions on each terrain will be represented in a separate file and you do not need to encode that in the PDDL domain file. If certain cells represent barriers, then make sure you cannot move onto those cells.

The types should include string 'agent', as well as other physical items, as objects. 

Note that you MUST include ALL objects under generic_objects of the object dictionary inside the PDDL :types under category of item.

You must include all generic_objects from the object dictionary in the PDDL types under type "items". The predicates should only be about the state or attribute of objects (e.g. you can define isshape, iscolor, isempty, etc.). Please do not include predicates that are not relevant for the agents' goals (i.e. donâ€˜t represent every possible object attribute). The types in the PDDL domain definition should refer to broad category of objects (e.g. fruit) and attributes (e.g. shape, color) and not specific instances, which can be defined in the PDDL problem file.

The task instructions will provide you with a list of actions that can be taken by the agent(s). Please do not invent any new actions in the PDDL domain file.

Here is an example:

Input: In this domain, you are observing a baby trying to reach some balls and plates. There are three unique balls: a tennis ball, a basketball and a baseball. The plates can have shapes of circle or square. The plates are placed inside cabinets. The agent can move up, down, left or right. There are whitespaces and plants (in green) in the map. The agents and objects can only exist in whitespaces.

objects = {'generic_objects': ['ball', 'plate', 'cabinet'], 'unique_objects': ['tennisball', 'basketball', 'baseball'], 'background_cells': ['whitespace', 'plant'], 'agent': ['baby']}

Output:

(define (domain example)
    (:requirements :fluents :adl :typing)
    (:types 
        ball plate  - item ; you may include objects from generic_objects["generic_objects"]
        item cabinet agent - object ; must include 'item', 'agent' and any other objects in generic_objects["generic_objects"] that the agent cannot pickup. Do not include the agent's name here (i.e. baby).
        shape ;this can be shape, color or other attributes
    )
    (:predicates 
        (has ?a - agent ?i - item)
        (at ?a - agent ?o - object) ; do not change
        (adjacent ?a - agent ?o - object) ; do not change
        (isplateshape ?p - plate ?s - shape)
        (isballshape ?b - ball ?s - shape)
    )

    (:constants 
        baby - agent ; name(s) of the agent(s) should be listed here,
        circle square - shape ; list kinds of attributes mentioned
        tennisball basketball baseball - ball ; list all unique objects
    )

    (:functions 
        (gridheight) - integer
        (gridwidth) - integer
        (xloc ?o - object) (yloc ?o - object) - integer
        (whitespace) (plant) - bit-matrix ; this should be an exact list as in generic_objects["background_cells"] 
    )

    (:derived (adjacent ?a ?i)(or (and (= (xloc ?a) (xloc ?i)) (= (- (yloc ?a) 1) (yloc ?i)))
                (and (= (xloc ?a) (xloc ?i)) (= (+ (yloc ?a) 1) (yloc ?i)))
                (and (= (- (xloc ?a) 1) (xloc ?i)) (= (yloc ?a) (yloc ?i)))
                (and (= (+ (xloc ?a) 1) (xloc ?i)) (= (yloc ?a) (yloc ?i)))))


    (:derived (at ?a ?i) (and (= (xloc ?a) (xloc ?i)) (= (yloc ?a) (yloc ?i))))

    (:action pickup
     :parameters (?a - agent ?i - item)
     :precondition
        (and (not (has ?a ?i)) 
            (adjacent ?a ?i)
     :effect 
        (and (has ?a ?i)
        (assign (xloc ?i) -1) (assign (yloc ?i) -1)
        )
    )
    )

    (:action up-white
     :parameters (?a - agent)
     :precondition
        (and (> (yloc ?a) 1)
            (= (get-index whitespace (yloc ?a) (xloc ?a)) true)
            (= (get-index blackspace (- (yloc ?a) 1) (xloc ?a)) false)
        )
     :effect
        (and (decrease (yloc ?a) 1))
    )

    (:action down-white
     :parameters (?a - agent)
     :precondition
        (and (< (yloc ?a) (gridheight))
            (= (get-index whitespace (yloc ?a)(xloc ?a)) true)
            (= (get-index blackspace (+ (yloc ?a) 1) (xloc ?a)) false)
        )
     :effect 
        (and (increase (yloc ?a) 1))
    )

    (:action left-white
     :parameters (?a - agent)
     :precondition
        (and (> (xloc ?a) 1)
            (= (get-index whitespace (yloc ?a) (xloc ?a)) true)
            (= (get-index blackspace (yloc ?a) (- (xloc ?a) 1)) false)
        )
     :effect
        (and (decrease (xloc ?a) 1))
    )

    (:action right-white
     :parameters (?a - agent)
     :precondition
        (and (< (xloc ?a) (gridwidth)) 
            (= (get-index whitespace (yloc ?a) (xloc ?a)) true)
            (= (get-index blackspace (yloc ?a) (+ (xloc ?a) 1)) false)
        )
     :effect
        (and (increase (xloc ?a) 1))
    )

)
********

In case where you can move on the black space but at a different cost:

    (:action right-white
     :parameters (?a - agent)
     :precondition
        (and (< (xloc ?a) (gridwidth)) 
            (= (get-index whitespace (yloc ?a) (xloc ?a)) true)
        )
     :effect
        (and (increase (xloc ?a) 1))
    )

    (:action right-black
     :parameters (?a - agent)
     :precondition
        (and (< (xloc ?a) (gridwidth)) 
            (= (get-index blackspace (yloc ?a) (xloc ?a)) true)
        )
     :effect
        (and (increase (xloc ?a) 1))
    )

********

Multiagent cases:

    If multiple agents are present, we use an agent-code to number the agents and a turn variable to indicate which agent is in turn to act.

    Include these in the functions only in cases with more than 1 agent:

            (agentcode ?a - agent) - integer
            (turn)- integer

    then you should check (= turn (agentcode ?a)) as a precondition for each agent's action. Then after completing the action, we would move on to the next agent:  (assign turn (- 1 turn))

********

Now please generate a PDDL domain given the input below:

